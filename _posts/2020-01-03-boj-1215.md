---
layout: single
title:  "[백준 1215] 잘못 작성한 조세퍼스 코드"
date:   2020-01-03
categories: 알고리즘
toc: true
---
[[문제 보기]](https://www.acmicpc.net/problem/1215)  

요즘 인턴 전까지 남는 시간을 때우기 위해 ps를 간간히 하고 있다. 오늘 소개하고자 하는 문제는 사실상 수학문제나 다름이 없다. 그러나 풀이를 알고 있으면 좋은 아이디어로 활용할 수 있는 여지가 크다고 생각하여 올리게 되었다! (`solved.ac` 기준 무려 플레티넘 5에 해당하는 문제이다.)
## 문제 설명
문제에는 조세퍼스라는 거창한(?) 이름이 등장하지만 문제 자체는 간단하다. 한마디로 요약하자면 n과 k가 주어졌을 때, 
$$
\sum_{i=1}^n \,k\,\bmod\,i
$$
를 빠르게 구하라는 것이다. (단, n과 k의 범위가 __1e9__ 까지이다.)
## 풀이
단순하게 전부 계산한다면 당연히도 시간초과가 난다. 우리는 최대한 연산의 횟수를 줄이고 싶다. 단순한 계산 외에 떠오르는 접근 방법에는 다음과 같은 것들이 있을 수 있겠다.

1. 나눗셈의 `나머지`를 기준으로 샌다.
2. 나눗셈의 `몫`을 기준으로 샌다.

1번의 경우 조금 생각해보면 그냥 계산하는 것보다도 오히려 느린 알고리즘이 될 수도 있다는 것을 알 수 있다. 그렇다면 2번의 경우 어떨까?  

약간의 관찰을 통해 우리는  임의의 자연수 j에 대하여 k/j >= l > k/(j+1) 인 정수 l에 대해서는 k/l의 몫이 j이라는 것을 알 수 있다. 이를 이용해 j가 주어진 경우에 한해서는 계산을 O(1) 안에 할 수 있다. 그러나 몫인 j가 1부터 k까지 전부 가능하기 때문에 결국 2번의 방법으로도 반복문을 k번 순회하는 수 밖에 없다.  

그러나, 여기서 오늘의 핵심 아이디어인 __범위 나누기__ 가 등장한다. j가 어느정도 큰 경우 반복문을 돌아봤자 해당하는 자연수 l의 개수가 0개가 되어 계산에 아무런 이득을 얻지 못한다는 사실을 관찰하는 것이 중요하다. 그래서 적절한 m - `여기선 m = sqrt(n) 이다` - 를 잡아 1부터 m까지의 '몫' 을 기준으로 한 번 계산하고, 다시 단순한 계산 방법(모듈러를 직접 계산하는 것)으로 나머지 수들을 계산한다. 그러면 두 계산에 모두 시간이 __O(sqrt(n))__ 만큼만 필요하게 되어, 제한시간 안에 해결이 가능하다! 이 외에도 자잘한 예외 처리가 필요하지만, 비교적 쉬우므로 생략한다.
## 코드
``` c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;

int main() {
    ll n, k, m, ans=0;
    scanf("%lld %lld",&n,&k);
    if(n>k) {
        ans+=k*(n-k);
    }
    m = sqrt(k);
    for(ll j=1; j<m; j++) {
        ll l=min(k/j,n), r=k/(j+1)+1; # 몫을 기준으로 범위 설정
        if(l<r) {
            continue;
        }
        ans += k*(l-r+1)-(l+r)*(l-r+1)*j/2;
    }
    for(ll j=1; j<=min(k/m,n); j++) {
        ans+=k%j;
    }
    printf("%lld",ans);
}
```
## 유사한 문제
[[잘못 구현한 에라토스테네스의 체]](https://www.acmicpc.net/problem/15897)
## 여담
오늘부터 본격적으로 블로그에 게시글을 올리게 되었다! 오늘은 일부러 마크다운 문법 연습도 해볼 겸 장황하게 설명을 해놓았지만, 다음번부터는 백준 문제풀이는 최대한 간략하게 써보려고 한다.